//шаблон класса-модуля для работы с системой глобальных событий//просто замените "Pattern" на свое название модуля и удалите лишние интерфейсы с методами#include "_global_events.fos"class Pattern : iManagerModule, iManager_loop,	iManager_critter_init, iManager_critter_finish,	iManager_critter_idle, iManager_critter_dead, iManager_critter_respawn,	iManager_map_critter_in, iManager_map_critter_out,	iManager_world_save, iManager_player_registration, iManager_player_login, iManager_time{	Pattern()	{				//AddStartCallback("<название скрипта>","start");	}		bool manager_init()	{		//вызывается в порядке приоритетов		return true;	}		uint global_loop()	{		return uint(-1);	}		bool global_critter_init(Critter& cr, bool firstTime)	{		return true;	}	bool global_critter_finish(Critter& cr, bool toDelete)	{		return true;	}	bool global_critter_idle(Critter& cr)	{		return true;	}	bool global_critter_dead(Critter& cr, Critter@ killer)	{		return true;	}	bool global_critter_respawn(Critter& cr)	{		return true;	}	bool global_map_critter_in(Map& map, Critter& cr)	{		return true;	}	bool global_map_critter_out(Map& map, Critter& cr)	{		return true;	}	bool global_world_save()	{		return true;	}	bool global_player_registration(uint ip, string& name, uint& textMsg, uint& strNum)	{		return true;	}	bool global_player_login(uint ip, string& name, uint id, uint& textMsg, uint& strNum)	{		return true;	}	bool global_time(int8 type)	{		/*		if((type&0xF)>=TIME_NEW_<MINUTE/HOUR/DAY/MONTH/YEAR>)		{			...		}		if(FLAG(type, TIME_NEW_WEEK))		{			...		}		*/		return true;	}}Pattern pattern;void start(){	iManagerModule@ module = pattern;	iManagerElement@ manager = manager_add_module(module, "Pattern", 20); //чем выше значение приоритета - тем раньше будут вызываться обработчики ивэнтов	if(manager is null) return;		//manager.TimeChangeCall() = TIME_NEW_<MINUTE/HOUR/DAY/MONTH/YEAR>;}