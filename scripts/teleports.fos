#include "_utils.fos"

import uint CountMapPlayers( Map@ map ) from "manager";

#define MaxSize		13
#define ListSize	( MaxSize - 3 )

//~run teleports go 0 0 0
void go( Critter& cr, int p0, int p1, int p2 )
{
	ShowTeleports(cr);
}

//import void ShowTeleports( Critter& cr ) from "teleports";
void ShowTeleports( Critter& cr ) //exported
{
	InitTeleports();
	cr.ParamBase[ST_VAR1] = 0;
	teleports.show( cr );
}

TeleportList@ teleports;
void InitTeleports()
{
	if( valid( teleports ) ) return;

	@teleports = CreateTeleports( "Телепорты" )
	//  .add( "NAME",	   LOCATIONPID,	MAP_N,   X,   Y )
	//Базовые:
		.add( "Активация",			LOCATION_START,		0, 337, 184 )
		.add( "Сон",				LOCATION_DREAM,		0, 296, 178 )
		.add( "Рай",				LOCATION_HEAVEN,	0, 129, 77 )
		.add( "Ад",					LOCATION_HELL,		0, 229, 177 )

	// FOnline Legacy
		.add( "[Пирс] Склады",				360,	0, 170, 270 )
		.add( "[Пирс] Подстанция",			361,	0, 170, 270 )
		.add( "[Пирс] Магазины",			362,	0, 170, 270 )
		.add( "[Пирс]",						363,	0, 170, 270 )
		.add( "[Пирс] Холм",				364,	0, 170, 270 )
		.add( "[Пирс] Медная шахта",		364,	1, 170, 270 )
		.add( "[Пирс] Руины",				365,	0, 170, 270 )
		.add( "[Пирс] Главная улица",		366,	0, 170, 270 )
		.add( "[Пирс] Сток",				367,	0, 170, 270 )
		.add( "[Пирс] Кэмпинг",				368,	0, 170, 270 )
		.add( "[Пирс] Лагерь",				369,	0, 170, 270 )
		.add( "[Пирс] Шахта 2",				370,	0, 170, 270 )
		.add( "[Пирс] Свинцовая шахта",		370,	1, 170, 270 )
		.add( "[Пирс] Шахта 3",				371,	0, 170, 270 )
		.add( "[Пирс] Угольная шахта",		371,	1, 170, 270 )

		.add( "[СФ] Порт",             114,    0, 0, 0 )
		.add( "[СФ] Центр",            1170,    0, 0, 0 )
		.add( "[СФ] Отель",            118,    0, 0, 0 )

		.add( "Шейди Сэндс",		111,	0,  62, 102 )
		.add( "Нью Рино",			112,	0, 269, 167 )

		.add( "РДР подвал",			52,		1, 480, 370 )
		.add( "РДР 2 этаж",			52,		2, 185, 160 )
		.add( "РДР 3 этаж",			52,		3, 152, 150 )
		.add( "Топь",				138,	0, 170, 270 )
		.add( "Старая часовня",		139,	0, 170, 270 )
		.add( "Лесное Племя",		130,	0, 170, 270 )
		.add( "Лес костей",			82,		0, 170, 270 )
		.add( "Западный Утес",		76,		0, 170, 270 )
		.add( "Мотель Псов",		77,		0, 170, 270 )
		.add( "Заброшенная шахта",	78,		0, 170, 270 )
		.add( "Племенная могила",	73,		0, 170, 270 )
		.add( "Распутье",			74,		0, 170, 270 )
		.add( "Дорога на Шейди",	75,		0, 170, 270 )
		.add( "Каньон",				72,		0, 170, 270 )
		.add( "Cтанция",			131,	0, 170, 270 )
		.add( "ШГ - Запад",			132,	0, 170, 270 )
		.add( "ШГ - Восток",		133,	0, 170, 270 )
		.add( "ШГ - Шахта",			133,	1, 190, 210 )
		.add( "Урановая Шахта",		133,	2, 165, 150 )
		.add( "Токсичная яма",		69,		0, 170, 270 )
		.add( "Каньон, Юг",			70,		0, 170, 270 )
		.add( "Логово Смерти",		71,		0, 170, 270 )
		.add( "Восточный склон",	134,	0, 170, 270 )
		.add( "Ущелье",				135,	0, 170, 270 )
		.add( "Западный Склон",		68,		0, 170, 270 )
		.add( "Дорога",				53,		0, 170, 270 )
		.add( "Побережье",			54,		0, 170, 270 )
		.add( "Чёртов остров",		136,	0, 170, 270 )
		.add( "Предгорье",			137,	0, 170, 270 )
		.add( "Рыбацкий привал",	67,		0, 170, 270 )
		.add( "Мост",				55,		0, 170, 270 )
		.add( "Утес",				56,		0, 170, 270 )
		.add( "Рудные Шахты",		57,		0, 170, 270 )
		.add( "Свинцовая Шахта",	60,		0, 170, 270 )
		.add( "Холмы",				61,		0, 170, 270 )
		.add( "Пляж",				62,		0, 170, 270 )
		.add( "Старая Шахта",		63,		0, 170, 270 )
		.add( "Руины",				64,		0, 170, 270 )
		.add( "Кладбище",			65,		0, 170, 270 )
		.add( "Промзона",			79,		0, 170, 270 )
		.add( "Центр",				80,		0, 170, 270 )
		.add( "Жилой Район",		81,		0, 170, 270 )
		.add( "Цветение",			83,		0, 170, 270 )
		.add( "Институт - 1эт",		83,		1, 205, 190 )

		.add( "Свалка",				250, 	0, 170, 270 )
		.add( "Племя",				251, 	0, 170, 270 )
		.add( "Дорога",				252, 	0, 170, 270 )
		.add( "Водокачка",			253, 	0, 170, 270 )
		.add( "Поселение",			254, 	0, 170, 270 )
		.add( "Лес",				255, 	0, 170, 270 )
		.add( "Угольная шахта",		256, 	0, 170, 270 )
	;
}

#ifndef __TELEPORT_CLASSES
	#define __TELEPORT_CLASSES
	
	class Pos
	{
		uint mapId;
		uint x;
		uint y;
		
		Pos( Critter& cr )
		{
			Map@ map = cr.GetMap();
			set( valid( map ) ? map.Id : 0, cr.HexX, cr.HexY );
		}
		
		Pos( Map@ map, uint x, uint y )	
		{
			set( valid( map ) ? map.Id : 0, x, y );
		}

		Pos( uint mapId, uint x, uint y )
		{
			set( mapId, x, y );
		}
		
		Pos@ set( uint mapId, uint x, uint y ) 
		{
			this.mapId = mapId;
			this.x = x;
			this.y = y;

			return this;
		}
		
		bool TransitToMap( Critter& cr )
		{
			if( mapId == 0 ) return false;
			
			Map@ map = GetMap( mapId );
			if( !valid( map ) ) return false;
			
			int attempt = 0;
			uint16 hexX = x, hexY = y;
			while( attempt < 10 )
			{
				if( !map.IsHexPassed( hexX, hexY ) )
					map.MoveHexByDir( hexX, hexY, Random( 0, 5 ), 1 );
				attempt++;
			}

			if( !map.IsHexPassed( hexX, hexY ) )
			{
				cr.Say( SAY_NETMSG, "Гексы заняты." );
				return false;
			}
			
			cr.TransitToMap( mapId, hexX, hexY, cr.Dir );
			
			Location@ loc = map.GetLocation();
			if( valid(loc) )
				cr.SetWorldPos( loc.WorldX, loc.WorldY );
			else
				cr.Say( SAY_NETMSG, "Вы не знаете, где точно находитесь." );
			
			return true;
		}
	}

	class Teleport
	{
		string name;
		uint LocationPID;
		uint MapNumber;
		Pos pos;
		
		Teleport( string name, uint locPID, uint mapN, uint x, uint y )
		{
			this.name = name;
			this.LocationPID = locPID;
			this.MapNumber = mapN;
			this.pos = Pos( getMap(), x, y );
		}
		
		Teleport( Critter& cr )
		{
			this.name = generateTeleportNameFromCritter( cr );
			this.pos = Pos( cr );
			
			this.MapNumber = 0;
			this.LocationPID = 0;
		}
		
		Map@ getMap()
		{
			return GetLocationMap( LocationPID, MapNumber );
		}
		
		string info()
		{
			if( MapNumber == 0 && LocationPID == 0 )
				return name;
			
			Map@ map = getMap();
			return "[" + ( valid( map ) ? "" + CountMapPlayers( map ) : ( LocationPID + ":" + MapNumber ) ) + "] " + name;
		}
		
		bool warp( Critter& cr )
		{
			return pos.TransitToMap( cr );
		}
	}

	//TODO: Группификаторы.
	
	class TeleportList
	{
		string name;
		Teleport[] list;
		int page;
		
		TeleportList( string name )
		{
			this.name = name;
			page = 0;
		}
		
		TeleportList@ add( string name, uint locPID, uint mapN, uint x, uint y )
		{
			return add( Teleport( name, locPID, mapN, x, y ) );
		}
		
		TeleportList@ add( Teleport teleport )
		{
			list.insertLast( teleport );
			return this;
		}
		
		bool show( Critter& cr )
		{
			Critter@[] crs;

			int x = cr.WorldX * 0.1, y = cr.WorldY * 0.1;
			string[] data = { "teleports@answer_TELEPORTS", "[" + x + ", " + y +"]\nСейчас " + CountMapPlayers( cr.GetMap() ) + " из " + GetAllPlayers( crs ) + " игроков на карте.", "[ИГРОКИ]" };

			int len = list.length();

			if( len > ListSize )
			{
				int start = page * ListSize;
				if( start < len )
				{
					int max = CLAMP( len, start, start + ListSize );
					data.insertLast( "[ НАЗАД ]" );
					for( int i = start; i < max; i++ )
						data.insertLast( list[i].info() );
					data.insertLast( "[ ВПЕРЕД ]" );
					DIALOG_MENU( cr, data );
				}
				else
				{
					page = 0;
					return show(cr);
				}
			}
			else
			{
				for( int i = 0; i < len; i++ )
					data.insertLast( list[i].info() );
				DIALOG_MENU( cr, data );
			}
			
			return len > 0;
		}
		
		bool process( Critter& cr, uint answer )
		{
			if( answer == 0 )
			{
				cr.ParamBase[ST_VAR1] = 1;
				return playersList().show( cr );
			}
			
			if( list.length() > ListSize )
			{
				if( answer == 1 )
				{
					page--;
					if( page < 0 )
						page = list.length() / ListSize;
					return show(cr);					
				}
				if( answer == ListSize + 2 || page * ListSize + answer - 2 == int( list.length() ) )
				{
					page++;
					if( page > int( list.length() / ListSize ) )
						page = 0;
					return show(cr);
				}
				return list[ page * ListSize + answer - 2 ].warp( cr );
			}
			
			if( answer <= list.length() )
				return list[answer - 1].warp( cr );
			
			return false;
		}
	}

PlayerList@ playersListInstance;

PlayerList@ playersList() {
	if( !valid( playersListInstance ) )
		@playersListInstance = PlayerList();
	
	return playersListInstance;
}

class PlayerList
{
	Teleport[] list;
	int page;
	
	uint online;
	
	PlayerList()
	{
		page = 0;
		online = 0;
	}
	
	PlayerList@ add( Critter@ cr )
	{
		if( !valid( cr ) ) return this;
		
		return add( Teleport( cr ) );
	}
	
	PlayerList@ add( Teleport teleport )
	{
		list.insertLast( teleport );
		return this;
	}
	
	bool refreshOnline()
	{
		Critter@[] crs;
		online = GetAllPlayers( crs );
		
		list.resize(0);
		
		for( uint i = 0; i < online; i++ )
			add( crs[i] );
		
		return true;
	}
	
	bool show( Critter& cr )
	{
		if( !refreshOnline() )
			return false;
		
		string[] data = { "teleports@answer_TELEPORTS", "Сейчас онлайн " + online + " игроков.", "[КАРТЫ]" };

		int len = list.length();

		if( len > ListSize )
		{
			int start = page * ListSize;
			if( start < len )
			{
				int max = CLAMP( len, start, start + ListSize );
				data.insertLast( "[ НАЗАД ]" );
				for( int i = start; i < max; i++ )
					data.insertLast( list[i].info() );
				data.insertLast( "[ ВПЕРЕД ]" );
				DIALOG_MENU( cr, data );
			}
			else
			{
				page = 0;
				return show(cr);
			}
		}
		else
		{
			for( int i = 0; i < len; i++ )
				data.insertLast( list[i].info() );
			DIALOG_MENU( cr, data );
		}
		
		return len > 0;
	}
	
	bool process( Critter& cr, uint answer )
	{
		if( answer == 0 )
		{
			ShowTeleports(cr);
			return true;
		}
		
		if( list.length() > ListSize )
		{
			if( answer == 1 )
			{
				page--;
				if( page < 0 )
					page = list.length() / ListSize;
				return show(cr);					
			}
			if( answer == ListSize + 2 || page * ListSize + answer - 2 == int( list.length() ) )
			{
				page++;
				if( page > int( list.length() / ListSize ) )
					page = 0;
				return show(cr);
			}
			return list[ page * ListSize + answer - 2 ].warp( cr );
		}
		
		if( answer <= list.length() )
			return list[answer - 1].warp( cr );
		
		return false;
	}
}
#endif

#ifndef __TELEPORT_SUBFUNCTIONS
	#define __TELEPORT_SUBFUNCTIONS
	
	string generateTeleportNameFromCritter( Critter& cr ) 
	{
		string map_name;

		Map @map = cr.GetMap();
		if( valid( map ) )
		{
			string@ buff = GetGmMsgStr( ( map.GetProtoId() + 1 ) * 10 + 8 );
			map_name = valid( buff ) ? buff : map.Id + "#" + map.GetProtoId();
		}
		else 
			map_name = "глобал";
		
		string state = "+";//В порядке.
		if( isGM( cr ) )
			state = "@";//Символ похож на G из слова GM.
		else if( cr.ParamBase[ QST_GAMEMODE ] == GAME_START )
			state = "!";//Нужно активировать!
		else if( cr.IsDead() )
			state = "%";//Похоже на череп с костями.
		else if( cr.Param[ST_CURRENT_HP] <= 0 )
			state = "-";//В минусах.
		else if( cr.IsKnockout() )
			state = "=";//В отключке, "ровный", чиллит.
		
		int x = cr.WorldX * 0.1, y = cr.WorldY * 0.1;
		
		//10:13#56+'Петя' Бар
		return x + ":" + y +"#" + cr.Id + state + "'" + cr.Name + "' " + map_name;
	}
	
	TeleportList@ CreateTeleports( string name )
	{
		return TeleportList( name );
	}

	Map@ GetLocationMap( uint location_pid )
	{
		return GetLocationMap( location_pid, 0 );
	}

	Map@ GetLocationMap( uint location_pid, uint map_index )
	{
		Location @ loc = GetLocationByPid( location_pid, 0 );
		if( !valid( loc ) ) 
		{
			Log( "There is no Location pid #" + location_pid + "." );
			return null;
		}
		Map @ map = loc.GetMapByIndex( map_index );
		if( !valid( map ) )
			Log( "There is no map # " + map_index + " at location pid #" + location_pid + "." );

		return map;
	}
	
	void answer_TELEPORTS( Critter& player, uint answerI, string& answerS )
	{
		switch( player.ParamBase[ST_VAR1] )
		{
			case(0): teleports.process( player, answerI ); break;
			case(1): playersList().process( player, answerI ); break;
		}
	}
#endif
