void CopyMob( Critter& master, Critter& slave )
{
	Map@ map = master.GetMap();
	if( !valid(map) ) return;
	
	Critter@ mob = map.AddNpc( slave.GetProtoId(), master.HexX, master.HexY, Random( 0, 5 ), null, null, null );
	clearInv( mob );  //Позволяет игнорить дефолтную сумку моба.
	master.RunClientScript( "client_gui@_SetControlCritters", mob.Id, 0, 0, null, null );
	FullClone( mob, slave );
	DublicateLoot( mob, slave );
}

void clearInv( Critter& cr )
{
	Item@[] items;
	
	cr.GetItems( SLOT_INV, items );
	cr.GetItems( SLOT_HAND1, items );
	cr.GetItems( SLOT_HAND2, items );
	cr.GetItems( SLOT_MISC, items );
	cr.GetItems( SLOT_HEAD, items );
	cr.GetItems( SLOT_BACK, items );

	Item@[] armors;
	uint count = cr.GetItems( SLOT_ARMOR, armors );
	
	if( count > 0 ) {
		MoveItem( armors[0], 1, cr );
		items.insertLast( armors[0] );
	}

	DeleteItems( items );
}

void FullClone( Critter& target, Critter& source )
{
	target.ChangeCrType( source.StatBase[ST_BASE_CRTYPE] );
	
	uint access = target.StatBase[ ST_ACCESS_LEVEL ];
	uint invis = target.ParamBase[ QST_INVIS ];
	uint vision = target.ParamBase[ QST_VISION ];
	uint sinf = target.ParamBase[ CR_SINF_MODE ];
	uint game_mode = target.ParamBase[ QST_GAMEMODE ];
	bool saveAccess = isGM( source ) || isGM( target );

	uint attr;
	for( attr = 0; attr < 200; attr++ )
		target.StatBase[attr] = source.StatBase[attr];

	for( attr = SKILL_BEGIN; attr <= SKILL_END; attr++ )
		target.SkillBase[attr] = source.SkillBase[attr];

	target.TagSkillBase[TAG_SKILL1] = source.TagSkillBase[TAG_SKILL1];
	target.TagSkillBase[TAG_SKILL2] = source.TagSkillBase[TAG_SKILL2];
	target.TagSkillBase[TAG_SKILL3] = source.TagSkillBase[TAG_SKILL3];
	target.TagSkillBase[TAG_SKILL4] = source.TagSkillBase[TAG_SKILL4];

	for( attr = TIMEOUT_BEGIN; attr <= TIMEOUT_END; attr++ )
		target.TimeoutBase[attr] = source.TimeoutBase[attr];
	
	for( attr = KILL_BEGIN; attr <= KILL_END; attr++ )
		target.KillBase[attr] = source.KillBase[attr];
	
	for( attr = PERK_BEGIN; attr <= PERK_END; attr++ )
		target.PerkBase[attr] = source.PerkBase[attr];
	
	for( attr = ADDICTION_BEGIN; attr <= ADDICTION_END; attr++ )
		target.AddictionBase[attr] = source.AddictionBase[attr];
	
	for( attr = KARMA_BEGIN; attr <= KARMA_END; attr++ )
		target.KarmaBase[attr] = source.KarmaBase[attr];

	for( attr = DAMAGE_BEGIN; attr <= DAMAGE_END; attr++ )
		target.DamageBase[attr] = source.DamageBase[attr];

	for( attr = MODE_BEGIN; attr <= MODE_END; attr++ )
		target.ModeBase[attr] = source.ModeBase[attr];
	
	for( attr = TRAIT_BEGIN; attr <= TRAIT_END; attr++ )
		target.TraitBase[attr] = source.TraitBase[attr];

	for( attr = REPUTATION_BEGIN; attr <= REPUTATION_END; attr++ )
		target.ReputationBase[attr] = source.ReputationBase[attr];
	
	for( attr = 700; attr <= 800; attr++ )
		target.ParamBase[attr] = source.ParamBase[attr];

	for( attr = MERC_BEGIN; attr <= MERC_END; attr++ )
		target.MercBase[attr] = source.MercBase[attr];
	
	if( !target.IsPlayer() )
	{
		target.SetFavoriteItem( SLOT_HAND1, source.GetFavoriteItem(SLOT_HAND1) );
		target.SetFavoriteItem( SLOT_HAND2, source.GetFavoriteItem(SLOT_HAND2) );
		target.SetFavoriteItem( SLOT_ARMOR, source.GetFavoriteItem(SLOT_ARMOR) );
	}
	
	//Не меняем уровня доступа и "настроек ГМки" для целевого криттера.
	//Не передаём нашу ГМку целевому криттеру и не сбрасываем нашу ГМку когда копируем его статы.
	if( saveAccess )
	{
		target.StatBase[ ST_ACCESS_LEVEL ] = access;
		target.ParamBase[ QST_GAMEMODE ] = game_mode;
		target.ParamBase[ QST_VISION ] = vision;
		target.ParamBase[ CR_SINF_MODE ] = sinf;
		target.ParamBase[ QST_INVIS ] = invis;
	}
}

void DublicateLoot( Critter& target, Critter& source )
{
	Item@[] item;
	uint count = source.GetItems( -1, item );
	
	for( uint i = 0; i < count; i++ )
	{
		Item@ clone = target.AddItem( item[i].GetProtoId(), item[i].GetCount() );
		DublicateItem( clone, item[i] );
		
		if( item[i].CritSlot != 0 )
			target.MoveItem( clone.Id, clone.GetCount(), item[i].CritSlot );
	}
}

void DublicateLoot( Item& target, Item& source )
{
	Item@[] item;
	uint count = source.GetItems( 0, item );
	
	for( uint i = 0; i < count; i++ )
	{
		Item@ clone = target.AddItem( item[i].GetProtoId(), item[i].GetCount(), 0 );
		DublicateItem( clone, item[i] );
	}
}

void DublicateItem( Item@ clone, Item@ source )
{
	if( !valid( clone ) || !valid( source ) ) return;
	if( source.Id == clone.Id || source.GetProtoId() != clone.GetProtoId() ) return;
	
	string@ lexems = Item_GetLexems( source );
	if( valid( lexems ) ) clone.SetLexems( lexems );
	
	clone.Flags = source.Flags;
	
	clone.PicMap = source.PicMap;
	clone.PicInv = source.PicInv == 0 ? source.PicMap : source.PicInv;

	clone.Val0 = source.Val0;
	clone.Val1 = source.Val1;
	clone.Val2 = source.Val2;
	clone.Val3 = source.Val3;
	clone.Val4 = source.Val4;
	clone.Val5 = source.Val5;
	clone.Val6 = source.Val6;
	clone.Val7 = source.Val7;
	clone.Val8 = source.Val8;
	clone.Val9 = source.Val9;
	
	clone.LockerId 		   = source.LockerId;
	clone.LockerComplexity = source.LockerComplexity;
	clone.LockerCondition  = source.LockerCondition;
	clone.Info 			   = source.Info;
	clone.TrapValue 	   = source.TrapValue;
	
	uint type = clone.GetType();
	
	if( type == ITEM_TYPE_WEAPON )
	{
		clone.AmmoCount = source.AmmoCount;
		clone.AmmoPid   = source.AmmoPid;
	}
	
	if( type == ITEM_TYPE_CONTAINER )
	{
		DublicateLoot( clone, source );
	}
	
	if( clone.IsDeteriorable() )
	{
		clone.Deterioration = source.Deterioration;
		clone.BrokenCount   = source.BrokenCount;
		clone.BrokenFlags   = source.BrokenFlags;
	}
	
	if( source.GetCount() > 1 )
	{
		clone.SetCount( source.GetCount() );
	}
	
	clone.Update();	
}

bool ReplaceWith( Item@ &item, uint pid, uint count = 1 )
{
	if( !valid( item ) ) return false;
	
	uint real_count = item.GetCount();
	if( count > real_count )
		return Warning( "Попытка заменить предмет большим количеством, чем имеется: " + count + " of " + real_count );
	
	if( pid == item.GetProtoId() || pid == 0 )
		return Warning( "Попытка заменить предмет некорректным пидом объекта: " + pid );
	
	Item@ result;
	switch( item.Accessory )
	{
		case( ACCESSORY_CRITTER ): { 
			Critter@ owner = GetCritter( item.CritId );
			if( !valid( owner ) )
				return Warning( "Хозяин объета не обнаружен: #" + item.CritId );
			else 
			{
				@result = owner.AddItem( pid, count );
				if( !valid( result ) )
					return Warning( "В ходе замены " + itemDesc( item ) + " не удалось добавить " + count + " " + itemName( pid ) + " хозяину #" + item.CritId );
			}
		break; }
		case( ACCESSORY_HEX ): {
			Map@ map = GetMap( item.MapId );
			if( !valid( map ) ) 
				return Warning( "Карта не найдена: #" + item.MapId );
			else
			{
				@result = map.AddItem( item.HexX, item.HexY, pid, count );
				if( !valid( result ) )
					return Warning( "В ходе замены " + itemDesc( item ) + " не удалось добавить " + count + " " + itemName( pid ) + " на карту #" + item.MapId + " в координаты: " + item.HexX + ", " + item.HexY );
			}
		break; }
		case( ACCESSORY_CONTAINER ): {
			Item@ container = GetItem( item.ContainerId );
			if( !valid( container ) )
				return Warning( "Контейнер-хозяин не найден: #" + item.ContainerId );
			else
			{
				@result = container.AddItem( pid, count, 0 );
				if( !valid( result ) )
					return Warning( "В ходе замены " + itemDesc( item ) + " не удалось добавить " + count + " " + itemName( pid ) + " в контейнер #" + item.ContainerId + " в координатах: " + container.HexX + ", " + container.HexY );
			}
		break; }
		case( ACCESSORY_NONE ): return Warning( "Объект " + itemDesc( item ) + " вне мира, его не заменить на " + itemName( pid ) + "." );
	}
	
	if( !valid( result ) )
		return Warning( "В ходе замены не был создан заменяющий предмет." );
	
	if( result.Val0 < result.Proto.Partial_Item )
		result.Val0 = result.Proto.Partial_Item;
	
	_SubItem( item, count );
	
	@item = @result;
	return true;
}

bool SpillOut( Item@ &item, int parts = 1 )//Возвращает "опустела-ли тара".
{
	if( !valid( item ) ) { return false;
	}
	
	int index = index_glass_bottles( item, 1 );
	
	if( index != -1 && !ReplaceWith( item, glass_bottles[2][index], 1 ) ) { //После этой ф-ии в &item уже указатель на предмет-замену.
		return false;
	}
	
	if( item.Proto.Partial_Item == 0 || item.Val0 < parts ) { //index_glass_bottles( item, 2 ) == -1 ||
		return false;
	}
	
	if( item.Val0 == 1 ) {
		uint16 itemPid = item.GetProtoId();
		if( Flasks.find( itemPid ) == -1 ) {
			return ReplaceWith( item, PID_BOTTLE_GLASS, 1 ); //Выпиваем остатки - заменяем указатель опустошённой тарой.
		}
	}
	
	item.Val0 -= parts;
	item.Val2 = item.Val0 * 100;
	item.Update();

	return true;
}

void ShowContainer( Critter& cr, Critter@ target, uint type )
{
	if( !valid( target ) ) return;

	cr.ParamBase[ST_LAST_CONT_ID] = 0;
	cr.StatBase[ST_LAST_CRIT_ID] = target.Id;
	
	cr.ShowContainer( target, null, type );
}

void ShowContainer( Critter& cr, Item@ target, uint type )
{
	if( !valid( target ) ) return;
	
	cr.ParamBase[ST_LAST_CONT_ID] = target.Id;
	cr.StatBase[ST_LAST_CRIT_ID] = 0;
	
	cr.ShowContainer( null, target, type );
}

void ChangeFrame( Item& item, uint8 frame )
{
    item.AnimStayBegin      = frame;
    item.AnimStayEnd        = frame;
    item.AnimShowBegin      = frame;
    item.AnimShowEnd        = frame;
    item.AnimHideBegin      = frame;
    item.AnimHideEnd        = frame;
    item.Update();
}

void femote( Critter& cr, string str )
{
    cr.Say( SAY_EMOTE_ON_HEAD, str);
}

void femote_Gender( Critter& cr, string str0, string str1)
{
    cr.Say( SAY_EMOTE_ON_HEAD, (cr.Stat[ ST_GENDER ] == GENDER_MALE ? str0 : str1 ) );
}

void SingleItemProtoChange( Critter& cr, uint16 pid, int slot = -1 )
{
	if( !valid( cr ) ) { return; }
	
	Item@ targetItem = cr.GetItem( 0, slot );
	if( valid( targetItem ) ) {
		cr.MoveItem( targetItem.Id, targetItem.GetCount(), SLOT_INV );
	}
	
	Item@ newItem = cr.AddItem( pid, 1 );
	if( valid( newItem ) ) {
		cr.MoveItem( newItem.Id, newItem.GetCount(), slot );
		
		targetItem.Val0 = newItem.Val0;
		targetItem.Val1 = newItem.Val1;
		targetItem.Val2 = newItem.Val2;
		targetItem.Val3 = newItem.Val3;
		targetItem.Val4 = newItem.Val4;
		targetItem.Val5 = newItem.Val5;
		targetItem.Val6 = newItem.Val6;
		targetItem.Val7 = newItem.Val7;
		targetItem.Val8 = newItem.Val8;
		targetItem.Val9 = newItem.Val9; 
	}
	
	_SubItem( targetItem, 1 );
}

//Change pickup flag
bool LockInPlace( Critter& cr, Item& targetItem )
{
	if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
	{	
		UNSETFLAG( targetItem.Flags, ITEM_CAN_USE );
		SETFLAG( targetItem.Flags, ITEM_CAN_PICKUP );
		cr.Say( SAY_NETMSG, "|0xFFFF00 Предмет поднимаем, теперь его можно перенести на новое место." );
	}
	else
	{		
		SETFLAG( targetItem.Flags, ITEM_CAN_USE );
		UNSETFLAG( targetItem.Flags, ITEM_CAN_PICKUP );
		cr.Say( SAY_NETMSG, "|0xFFFF00 Предмет надежно закреплен." );
	}
	return true;
}

//Pick up items, max weight and volume check
bool PickItem( Critter& cr, Item& targetItem )
{	
	Item@ item = targetItem;
	if( !FLAG( item.Flags, ITEM_CAN_PICKUP ) ) {
		cr.Say( SAY_NETMSG, "Это не поднять." );
		return false;
	}	
	
	int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
	
	_testInfo( cr, CR_TEST_MODE_SPEED, SAY_NETMSG, "Поднимаем: " + ItemsWeight( targetItem ) + " грамм." );
	
	if( !isGM( cr ) && !item.IsStackable() && int(ItemsWeight( targetItem )) > freeWeight ) {
		cr.Say( SAY_NETMSG, "Слишком тяжело." );
		return false;
	}
	
	int amount1 = item.GetCount();
	if( !isGM( cr ) && freeWeight < int( item.Proto.Weight * item.GetCount() ) ) {
		amount1 = 0;
		if( item.IsStackable() && freeWeight >= int(item.Proto.Weight) ) {
			amount1 = freeWeight / item.Proto.Weight;
		}	
	}
	
	int freeVolume = CRITTER_MAX_VOLUME - cr.ItemsVolume();
	int amount2 = item.GetCount();
	if( !isGM( cr ) && freeVolume < int( item.Proto.Volume * item.GetCount() ) ) {
		amount2 = 0;
		if( item.IsStackable() && freeVolume >= int(item.Proto.Volume) ) {
			amount2 = freeVolume / item.Proto.Volume;
		}
	}
	
	if( amount1 * amount2 != 0 ) {
		MoveItem( item, MIN( amount1, amount2 ), cr );			
	
	} else {
		string desc = "Вы не можете это поднять, так как несете ";
		desc += ( amount1 == 0 ? "максимальный груз" + ( amount2 == 0 ? " и " : "" ) : "" );
		desc += ( amount2 == 0 ? "слишком много предметов" : "" );				
		cr.Say( SAY_NETMSG, desc + "." );
	}
	
	return true;
}