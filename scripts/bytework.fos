#include "_macros.fos"
#include "_maps.fos"
#include "_colors.fos"

//Ок, тогда то же самое, но ф-ями:```cpp
//Ф-я, необходимая для более удобной отладки, псевдо "throw exception".
uint uint_Safe_trowException( string text ) { void_Safe_trowException(text); return 0; }
bool bool_Safe_trowException( string text ) { void_Safe_trowException(text); return false; }
void void_Safe_trowException( string text ) { Log( "Exception:" + text ); }

//Вспомогательные математические функции:
#ifndef __SIMPLE_MATH
#define __SIMPLE_MATH

bool inRange( int val, int min, int max )
{
	return min <= max && val >= min && val <= max;
}

float pow( int number, int degree ) //Возведение числа number в степень degree
{
	if( degree == 0 ) return 1;
	
	if( degree < 0 )
		return ( 1 / number ) * pow( number, degree + 1 );
	else
		return number * pow( number, degree - 1 );
}

#endif

//Основные вспомогательные побитовые функции:
#ifndef __SIMPLE_BYTES
#define __SIMPLE_BYTES

#define BYTE_MAX		(16)
#define BYTE_LENGTH		(2)
#define BYTE_COUNT		( BYTE_MAX / BYTE_LENGTH )

#define MIN_PARAM	(700)
#define MAX_PARAM	(800)
bool CorrectInputArgs( Critter& cr, uint param_number, uint index ) //подфункция проверки входных аргументов, рассчитанная на использование лишь своими "хозяевами" в данном модуле.
{
	if( !inRange( param_number, MIN_PARAM, MAX_PARAM ) || index >= BYTE_COUNT ) 
		return bool_Safe_trowException( "Input args - [Out of range]: " + param_number + " " + index );
	
	int value = cr.ParamBase[param_number];
	if( value < 0 || value > pow( 2, BYTE_MAX ) ) 
		return bool_Safe_trowException( "Critter params - [Out of range]: " + value );
	
	return true;
}

uint getByteVal( Critter& cr, uint param_number, uint index )
{
	if( !CorrectInputArgs( cr, param_number, index ) ) return 0;
	
	int val = cr.ParamBase[param_number];
	for( uint i = 0; i < index; i++ )
		val = val >> BYTE_LENGTH;
	
	return val % pow( 2, BYTE_LENGTH ); //Остаток от деления val на 2 (0x10) в нужной нам степени BYTE_LENGTH. Даёт числовой эквивалент значения нужного нам флага.
}

uint setByteVal( Critter& cr, uint param_number, uint index, uint val )
{
	if( !CorrectInputArgs( cr, param_number, index ) ) return 0;
	
	if( int( val ) >= pow( 2, BYTE_LENGTH ) ) return uint_Safe_trowException( "Input val - [Out of range]: " + val );
	
	//Сначала очищаем целевые биты, затем записываем в них новые значения.
	int result = cr.ParamBase[param_number];
	for( uint i = 0; i <= index; i++ )
		result = result >> BYTE_LENGTH;
	
	result = ( result << BYTE_LENGTH ) + val;
	
	for( uint i = 0; i < index; i++ )
		result = result << BYTE_LENGTH;
	
	if( index > 0 )
		result += cr.ParamBase[param_number] % pow( 2, BYTE_LENGTH * index );
	
	cr.ParamBase[param_number] = result;
	return cr.ParamBase[param_number];
}
#endif

void test( Critter& cr, int p0, int p1, int p2 )
{
	cr.Say( SAY_NORM, "Поехали!" );
	cr.ParamBase[CR_VAL0] = ( p0 == 0 ? Random( 0, pow( 2, BYTE_MAX - 1 ) ) : p0 );
	
	if( p1 != 0 && p2 != 0 ) //Чисто тестовый прогон, без красивостей.
	{
		string result = cr.ParamBase[CR_VAL0];
		result += " => " + setByteVal( cr, CR_VAL0, p1, p2 );
		cr.Say( SAY_NETMSG, result );
		return;
	}
	
	string info = "Вот вводная:\nЕсли взять число 10, то в двоичной системе счисления это будет 2+8 (0х1010)."
		+ "\nЕсли мы сдвинем его \"вправо\" на 2 разряда, то получится число, в 2^2 меньшее, с округлением вниз: 2 (0х10)."
		+ "\nЕсли же полученное число мы сдвинем на 2 разряда влево, то получим число в 2^2 раз большее: 8 (0х1000).";
	int val = 10;
	info += "\nДоказательство: " + val + " -> " + ( val >> 2 ) + " -> " + ( ( val >> 2 ) << 2 ) + ".";
	cr.Say( SAY_NETMSG, info );
	
	info = "Значения флагов до [" + cr.ParamBase[CR_VAL0] + "]:";
	for( uint i = 0; i < BYTE_COUNT; i++ )
		info += "\n" + i + ") " + getByteVal( cr, CR_VAL0, i );
	cr.Say( SAY_NETMSG, info );
	
	info = "Значения флагов в ходе:";
	for( uint i = 0; i < BYTE_COUNT; i++ ) 
	{
		int rnd = Random( 0, pow( 2, BYTE_LENGTH ) - 1 );
		info += "\n" + i + ") " + getByteVal( cr, CR_VAL0, i ) + " -> " + rnd + " == ";
		info += setByteVal( cr, CR_VAL0, i, rnd ); //В одну строку нельзя - т.к. тогда ф-ии будут выполняться справа-налево (сначала set, потом get), а нам нужно наоборот.
	}
	cr.Say( SAY_NETMSG, info );

	info = "Значения флагов после [" + cr.ParamBase[CR_VAL0] + "]:";
	for( uint i = 0; i < BYTE_COUNT; i++ )
		info += "\n" + i + ") " + getByteVal( cr, CR_VAL0, i );
	cr.Say( SAY_NETMSG, info );
}