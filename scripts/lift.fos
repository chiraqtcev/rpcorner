#ifndef LIFT
#define LIFT

#include "_utils.fos"
#include "effects_h.fos"

int[][] lifts_hexes = {
//  Lift item           Door hex    KO hex    Critter hexes
//  ProtoId             X   Y       X   Y     X   Y   X   Y   X   Y   X   Y   X   Y
    {PID_LIFT_1,        0,  2,      0,  4,    0,  0,  0,  1, -1,  1,  1,  1, -1,  2}
};

bool lifts_initialized = false;
uint[][] lifts_ids;

#define GROUP_INDEX_PID       0
#define GROUP_INDEX_CURRENT   1
#define GROUP_INDEX_GOING_TO  2
#define GROUP_INDEX_COOLDOWN  3
#define GROUP_INDEX_FIRST     4
#define GROUP_GET_FLOOR # (__GROUP_GET_FLOOR_group, __GROUP_GET_FLOOR_floor) (__GROUP_GET_FLOOR_group[GROUP_INDEX_FIRST-1+__GROUP_GET_FLOOR_floor])

#define FRAME_VACANT 0
#define FRAME_ARRIVED 1

#define HEXES_INDEX_DOOR 1
#define HEXES_INDEX_KO 3
#define HEXES_INDEX_FIRST 5

#define ACCESS_INITAL 0
#define ACCESS_SELECT 1
#define ACCESS_DOOR   2

void _LiftInit( Item& item, bool firstTime ) {    
    //item.SetEvent( ITEM_EVENT_WALK, "e_LiftWalk" );
    lifts_initialized = false;
    item.SetEvent( ITEM_EVENT_SKILL, "e_LiftSkill" );
    CreateTimeEvent( __FullSecond + REAL_SECOND(3), "e_LiftAutoInit", item.Id, false );
}

uint e_LiftAutoInit( uint[] @ val ) {
    if( !lifts_initialized ) {
        InitializeLifts();
    }
    return 0;
}

void resetLifts( Critter& cr, int p1, int p2, int param2 ) {
    lifts_initialized = false;
    InitializeLifts();
}

void menu( Critter& cr, int group, int floor, int safe ) {
    if( group == 0 || group > 99 ) {
        cr.Say(SAY_NETMSG, "Invalid lifts' group: "+group);
        return;
    }
    if(floor == 0) {
        floor = GetGroupCurrentFloor(group);
    }
    if( floor == 0 || floor > 99 ) {
        cr.Say(SAY_NETMSG, "Invalid lifts' group: "+floor);
        return;
    }
    uint item_id = GetLift(group, floor);
    Item@ item = GetItem(item_id);
    if(item is null) {
        cr.Say(SAY_NETMSG, "Item is null");
    } else {
        LiftActivate(item, cr, safe==1);
    }
}

int[]@ GetLiftHexes(uint16 pid) {
    for(uint i=0, len=lifts_hexes.length(); i<len; i++) {
        int[]@ hexes = lifts_hexes[i];
        uint hexes_length = hexes.length();
        if(hexes_length == 0 || hexes[0] != pid) {
            continue;
        }
        if(hexes_length < HEXES_INDEX_FIRST+2 || hexes_length%2==0) {
            Log("Invalid lift hexes settings: "+i+" pid "+pid);
            return null;
        }
        return hexes;
    }
    return null;
}

uint GroupLength(uint[]& group) {
    uint len = group.length();
    if (len <= GROUP_INDEX_FIRST) {
        return 0;
    }
    return len-GROUP_INDEX_FIRST;
}

uint GetLift(uint group, uint floor) {
    if (lifts_ids.length() < group) {
        return 0;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (GroupLength(group_ids) < floor) {
        return 0;
    }
    return GROUP_GET_FLOOR(group_ids, floor);
}

Item@ GetLiftItem(uint group, uint floor) {
    uint id = GetLift(group, floor);
    if(id != 0) {
        return GetItem(id);
    }
    return null;
}

uint GetGroupType(uint group) {
    if (lifts_ids.length() < group) {
        return 0;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (group_ids.length() <= GROUP_INDEX_PID) {
        return 0;
    }
    return group_ids[GROUP_INDEX_PID];
}
uint GetGroupCurrentFloor(uint group) {
    if (lifts_ids.length() < group) {
        return 0;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (group_ids.length() <= GROUP_INDEX_CURRENT) {
        return 0;
    }
    return group_ids[GROUP_INDEX_CURRENT];
}
Item@ GetGroupCurrentItem(uint group) {
    uint floor = GetGroupCurrentFloor(group);
    if(floor == 0) {
        return null;
    }
    return GetLiftItem(group, floor);
}

bool SetLift(uint16 pid, uint group, uint floor, uint item_id, bool arrived) {
    if (lifts_ids.length() < group) {
        lifts_ids.resize(group);
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if (group_ids.length() == 0) {
        group_ids.resize(GROUP_INDEX_FIRST);
        group_ids[GROUP_INDEX_PID] = pid;
        group_ids[GROUP_INDEX_CURRENT] = 0;
        group_ids[GROUP_INDEX_GOING_TO] = 0;
        group_ids[GROUP_INDEX_COOLDOWN] = 0;
    }
    if (arrived) {
        if(group_ids[GROUP_INDEX_CURRENT] == 0) {
            Log("Group "+group+" lift arrived at floor "+floor);
            group_ids[GROUP_INDEX_CURRENT] = floor;
        } else {
            Log("Two arrived lifts per group "+group+", "+group_ids[GROUP_INDEX_CURRENT]+" and "+floor+", fixing...");
            arrived = false;
        }
    }
    
    uint group_ids_len = group_ids.length();
    if (GroupLength(group_ids) < floor) {
        uint len = GROUP_INDEX_FIRST+floor;
        group_ids.resize(len);
        for(uint i=group_ids_len; i<len; ++i) {
            group_ids[i] = 0;
        }
    }
    GROUP_GET_FLOOR(group_ids, floor) = item_id;
    return arrived;
}

bool IsSettingsValid(uint group, uint floor) {
    if( group == 0 || group > 99 ) {
        Log("Invalid lifts' group: "+group);
        return false;
    }
    if( floor == 0 || floor > 99 ) {
        Log("Invalid lifts' floor: "+floor);
        return false;
    }
    return true;
}

uint InitializeLiftsFor(uint16 pid) {
    int[]@ hexes = GetLiftHexes(pid);
    if(hexes is null) {
        Log("Unsupported lift proto: "+pid);
        return 0;
    }

    Item@[] items;
    uint _count = GetAllItems (pid, items);
    uint count_ok = 0;

    for(uint i=0, l=items.length(); i<l; ++i) {
        Item@ item = items[i];
        uint group = item.Val1;
        uint floor = item.Val2;
        if (!IsSettingsValid(group, floor)) {
            continue;
        }
        uint group_type = GetGroupType(group);
        if (group_type != 0 && group_type != pid) {
            LiftDebug("Different prototypes of lifts in the same group: "+pid+" != "+group_type, item);
            continue;
        }
        uint prev_lift = GetLift(group, floor);
        if( prev_lift != 0 ) {
            LiftDebug("Collision of lifts' settings, previous value: "+prev_lift, item);
            continue;
        }
        uint16 item_hexX = 0, item_hexY = 0;
        Map@ item_map = item.GetMapPosition (item_hexX, item_hexY);
        if(item_map is null) {
            LiftDebug("Lift item isn't on map", item);
            continue;
        }

        Item@ door = FindDoor(item_map, item, hexes);
        if(door is null) {
            LiftDebug("Lift has no door", item);
            continue;
        }
        door.Val1 = group;
        door.Val2 = floor;
        door.SetEvent( ITEM_EVENT_SKILL, "e_DoorSkill" );

        bool arrived = SetLift(pid, group, floor, item.Id, item.AnimShowBegin==FRAME_ARRIVED);
        ChangeLift(item_map, item, hexes, door, arrived, arrived);
        count_ok += 1;
    }
    return count_ok;
}

Item@ FindDoor(Map& map, Item& lift, int[]& hexes) {
    int door_shift_x = hexes[HEXES_INDEX_DOOR];
    int door_shift_y = hexes[HEXES_INDEX_DOOR+1];
    return map.GetDoor(lift.HexX+door_shift_x, lift.HexY+door_shift_y);
}

bool ChangeLift(Map& map, Item& lift, int[]& hexes, Item& door, bool arrived, bool opened) {
    int ko_shiftX = hexes[HEXES_INDEX_KO];
    int ko_shiftY = hexes[HEXES_INDEX_KO+1];

    if(arrived) {
        ChangeFrame(lift, FRAME_ARRIVED);
    } else {
        ChangeFrame(lift, FRAME_VACANT);
    }

    if(opened) {
        door.LockerOpen();
    } else {
        Critter@ cr = map.GetCritter(door.HexX, door.HexY);
        if(cr !is null) {
            uint16 nex_hexX = lift.HexX+ko_shiftX;
            uint16 nex_hexY = lift.HexY+ko_shiftY;

            if(!cr.TransitToHex(nex_hexX, nex_hexY, 6)) {
                return false;
            }
            cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT(true), 100, cr.HexX, cr.HexY );
        }
        if(!door.LockerClose()) {
            Log("Can't close prev lift door");
            return false;
        }
    }

    return true;
}

void InitializeLifts() {
    lifts_initialized = true;
    lifts_ids.resize(0);
    uint count_ok = 0;
    for(uint i=0, len=lifts_hexes.length(); i<len; i++) {
        int[]@ hexes = lifts_hexes[i];
        uint hexes_length = hexes.length();
        if(hexes_length == 0) {
            continue;
        }
        uint16 pid = hexes[0];
        if(hexes_length < HEXES_INDEX_FIRST+2 || hexes_length%2==0) {
            Log("Invalid lift hexes settings: "+i+" pid "+pid);
            continue;
        }
        count_ok += InitializeLiftsFor(pid);
    }
    Log("Lifts initialized: "+count_ok);
}

void LiftDebug(string@& message, Item& item) {
    uint16 hexX = 0, hexY = 0;
    Map@ map = item.GetMapPosition (hexX, hexY);
    if(map is null) {
        Log(message+"; item.Id: "+item.Id+", group: "+item.Val1+", floor: "+item.Val2+", map is null");
    } else {
        Log(message+"; item.Id: "+item.Id+", group: "+item.Val1+", floor: "+item.Val2+
            ", map.Id: "+map.Id+", hexX: "+hexX+", hexY: "+hexY);
    }    
}

//import bool e_DoorSkill( Item& door, Critter& cr, int skill ) from "lift";
bool e_DoorSkill( Item& door, Critter& cr, int skill ) {
    if( skill != SKILL_PICK_ON_GROUND ) {
        return true;
    }
    if( DoorActivate(door, cr) ) {
        femote_Gender(cr, "вызвал лифт", "вызвала лифт");
    }
    return true;
}

bool CheckLiftAvaible(Critter& cr, uint[]& group_ids, uint cooldown) {
    uint going_to = group_ids[GROUP_INDEX_GOING_TO];
    if(going_to!=0) {
        cr.Say(SAY_NETMSG, "Лифт занят.");
        return false;
    }
    uint timestamp = group_ids[GROUP_INDEX_COOLDOWN];
    if(timestamp+cooldown > __FullSecond) {
        cr.Say(SAY_NETMSG, "Лифт перезаряжается.");
        return false;
    }
    return true;
}

bool DoorActivate( Item& door, Critter& cr ) {
    if(_LockerIsOpen(door)) {
        return false;
    }

    uint group = door.Val1;
    uint floor = door.Val2;
    if (!IsSettingsValid(group, floor)) {
        return false;
    }
    Item@ parent_lift = GetLiftItem(group, floor);
    if(parent_lift is null) {
        LiftDebug("Can't find parent lift of the door", door);
        return false;
    }
    Item@ current_lift_item = GetGroupCurrentItem(group);
    if(current_lift_item is null) {
        LiftDebug("No current floor", door);
        return false;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    if( !CheckLiftAvaible(cr, group_ids, REAL_SECOND(10)) ) {
        return false;
    }

    if(!CanAccessFloor(cr, group, floor, ACCESS_DOOR)) {
        //player can't use lift door on this floor
        return false;
    }

    return MoveLiftTo(current_lift_item, floor, true);
}

bool e_LiftSkill( Item& item, Critter& cr, int skill ) {
    if( skill == SKILL_PICK_ON_GROUND ) {
        LiftActivate(item, cr, true);
        return true;
    }
    return false;
}
/*
void e_LiftWalk( Item& item, Critter& cr, bool entered, uint8 dir ) {
    if( entered ) {
        LiftActivate(item, cr, true);
    }
}
*/
void LiftActivate(Item& item, Critter& cr, bool safe) {
    if( !lifts_initialized ) {
        InitializeLifts();
    }

    if (cr.IsNpc()) {
        //npc can't activate lift
        return;
    }
    uint16 item_hexX = 0, item_hexY = 0;
    Map@ item_map = item.GetMapPosition (item_hexX, item_hexY);
    if (item_map is null) {
        LiftDebug("Player "+cr.Id+" is activating lift which is not on the map", item);
        return;
    }

    if( safe ) {
        Map@ map = cr.GetMap();
        if (map is null) {
            LiftDebug("Player "+cr.Id+" is activating lift while on global", item);
            return;
        }

        if (item_map.Id != map.Id) {
            LiftDebug("Player "+cr.Id+" is activating lift which is on the other map", item);
            return;
        }
    }    

    uint group = item.Val1;
    uint floor = item.Val2;
    if (!IsSettingsValid(group, floor)) {
        return;
    }
    uint lift_id = GetLift(group, floor);
    if (lift_id == 0 || lift_id != item.Id) {
        LiftDebug("Player is activating lift that's not registered correctly", item);
        return;
    }
    uint[]@ group_ids = lifts_ids[group-1];
    uint floors_in_group = GroupLength(group_ids);
    if( floors_in_group == 0) {
        //empty group
        return;
    }
    if( !CheckLiftAvaible(cr, group_ids, REAL_SECOND(5)) ) {
        //lift can't be used just yet
        return;
    }

    GameVar@ var_item_id = GetLocalVar(LVAR_menu_lift_id, cr.Id);
    if(var_item_id is null) {
        Log("LVAR_menu_lift_id is null for player "+cr.Id);
        return;
    }
    var_item_id = item.Id;
	
    if(safe) {
        if(!CanAccessFloor(cr, group, floor, ACCESS_INITAL)) {
            //player can't use lift on this floor
            return;
        }
    }

    cr.ShowScreen( SCREEN_DIALOGBOX, floors_in_group-1, safe ? "answer_LiftMenuHandler" : "answer_LiftMenuHandler_unsafe" );
    cr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, FOTEXT_LIFT(group, floor) );
    for(uint i=0, j=1; j<=floors_in_group; ++j) {
        if(j==floor) {
            continue;
        }
        cr.SayMsg( SAY_DIALOGBOX_BUTTON( i ), TEXTMSG_TEXT, FOTEXT_LIFT(group, j));
        i+=1;
    }
}

void answer_LiftMenuHandler( Critter& player, uint answerI, string& answerS ){
    if(LiftMenuHandler(player, answerI, true)) {
        femote_Gender(player, "активировал лифт", "активировала лифт");
    }
}

void answer_LiftMenuHandler_unsafe( Critter& player, uint answerI, string& answerS ){
    LiftMenuHandler(player, answerI, false);
}

bool LiftMenuHandler( Critter& player, uint answerI, bool safe ){
    GameVar@ var_item_id = GetLocalVar(LVAR_menu_lift_id, player.Id);
    if(var_item_id is null) {
        Log("LVAR_menu_lift_id is null for player "+player.Id);
        return false;
    }
    uint item_id = var_item_id.GetValue();
    if(item_id == 0) {
        Log("Player "+player.Id+" answers lift menu but menu_lift_id game var holds 0 value");
        return false;
    }
    Item@ item;
    if(safe) {
        Map@ player_map = player.GetMap();
        if(player_map is null) {
            Log("Player "+player.Id+" answers lift menu while on global");
            return false;
        }
        @item = player_map.GetItem(item_id);
    } else {
        @item = GetItem(item_id);
    }
    
    //Item@ item = FindLiftItem(player_map, player.HexX, player.HexY);
    //var_item_id = item.Id;

    if(item is null) {
        Log("Player "+player.Id+" answers lift menu but there is no lift with Id "+item_id);
        return false;
    }

    if(safe) {
        if( item.MapId == 0 ) {
            LiftDebug("Lift isn't on the map", item);
            return false;
        }
        if( item.MapId != player.GetMapId() ) {
            LiftDebug("Player "+player.Id+" is on the different map than lift", item);
            return false;
        }
        if( GetDistantion(player.HexX, player.HexY, item.HexX, item.HexY) > 1 ) {
            LiftDebug("Player "+player.Id+" is too far away from lift", item);
            return false;
        }
    }

    uint group = item.Val1;
    uint floor = item.Val2;

    uint next_floor = answerI+1;
    if( floor<=next_floor ) {
        next_floor += 1;
    }

    if(safe) {
        if(!CanAccessFloor(player, group, floor, ACCESS_SELECT, next_floor)) {
            //player can't send lift to this floor
            return false;
        }
    }

    return MoveLiftTo(item, next_floor, true);
}

bool MoveLiftTo( Item& item, uint next_floor, bool initial) {
    uint group = item.Val1;
    uint floor = item.Val2;
    if (!IsSettingsValid(group, floor) || GetLift(group, floor) != item.Id) {
        return false;
    }

    uint16 prev_hexX = 0, prev_hexY = 0;
    Map@ prev_map = item.GetMapPosition (prev_hexX, prev_hexY);
    if( prev_map is null ) {
        LiftDebug("Lift isn't on the map", item);
        return false;
    }
    
    uint[]@ group_ids = lifts_ids[group-1];
    uint floors_in_group = GroupLength(group_ids);

    if(floors_in_group == 0) {
        //empty group
        return false;
    }
    /*uint cooldown = group_ids[GROUP_INDEX_COOLDOWN];
    if( cooldown > __FullSecond ) {
        //lift is on cooldown
        return;
    }*/
    int[]@ hexes = GetLiftHexes(group_ids[0]);
    if(hexes is null) {
        LiftDebug("No hex settings for this lift item prototype", item);
        return false;
    }
    Item@ prev_door = FindDoor(prev_map, item, hexes);
    if(prev_door is null) {
        LiftDebug("Lift has no door", item);
        return false;
    }
    uint going_to = group_ids[GROUP_INDEX_GOING_TO];
    if(initial) {
        if(going_to != 0) {
            //already moving, can't interfere
            return false;
        }
        if (next_floor == 0) {
            //should be known
            return false;
        }
    } else {
        if (going_to == 0) {
            //already stopped, can't move
            return false;
        }
        if (next_floor == 0) {
            group_ids[GROUP_INDEX_GOING_TO] = 0;
            group_ids[GROUP_INDEX_COOLDOWN] = __FullSecond;
            ChangeLift(prev_map, item, hexes, prev_door, true, true);
            return true;
        }
    }
    if(next_floor == floor) {
        //we are already on this floor
        return false;
    }
    if( next_floor > floors_in_group) {
        LiftDebug("Next floor is highter than maximum", item);
        return false;
    }
    if( group_ids[GROUP_INDEX_CURRENT] != floor ) {
        LiftDebug("Lift shaft is vacant", item);
        return false;
    }

    uint go_to_floor = (next_floor<floor) ? (floor-1) : (floor+1);

    uint next_floor_item_id = GROUP_GET_FLOOR(group_ids, go_to_floor);

    if(next_floor_item_id == 0) {
        LiftDebug("Gap in floors", item);
        return false;
    }

    Item@ next_lift = GetItem(next_floor_item_id);
    if(next_lift is null) {
        LiftDebug("Next lift with item.Id "+next_floor_item_id+" is invalid", item);
        return false;
    }
    uint16 next_hexX = 0, next_hexY = 0;
    Map@ next_map = next_lift.GetMapPosition (next_hexX, next_hexY);
    if(next_map is null) {
        LiftDebug("Next lift with item.Id "+next_floor_item_id+" isn't on map", item);
        return false;
    }

    Item@ next_door = FindDoor(next_map, next_lift, hexes);
    if(next_door is null) {
        LiftDebug("Lift has no door", next_lift);
        return false;
    }

    if(_LockerIsOpen(next_door)) {
        Log("Next lift door is open, can't move");
        return false;
    }
    
    //ChangeLift(next_map, next_lift, next_door, true, false);

    if(_LockerIsOpen(prev_door)) {
        if( !ChangeLift(prev_map, item, hexes, prev_door, true, false) ) {
            return false;
        }
    }

    if(initial) {
        group_ids[GROUP_INDEX_GOING_TO] = next_floor;
        //uint floor_diff = uint(abs(int(next_floor) - int(floor)));
        prev_map.PlaySound("ELEVATO1.ACM", prev_hexX, prev_hexY, 10);
        uint[] arr = {item.Id, go_to_floor};
        CreateTimeEvent( __FullSecond + REAL_SECOND(2), "e_LiftMoving", arr, false );
        return true;
    }

    for(uint i=HEXES_INDEX_FIRST, len=hexes.length(); i<len; i+=2) {
        int diff_hexX = hexes[i];
        int diff_hexY = hexes[i+1];
        Critter@ cr = prev_map.GetCritter(prev_hexX+diff_hexX, prev_hexY+diff_hexY);
        if( cr is null ) {
            continue;
        }
        if( cr.IsPlayer()) {
            FlushScreen(cr, true, 2000);
        }
        cr.TransitToMap(next_map.Id, next_hexX+diff_hexX, next_hexY+diff_hexY, 6);
    }
    
    next_map.PlaySound("ELEVATOR.ACM", next_hexX, next_hexY, 10);
    group_ids[GROUP_INDEX_CURRENT] = next_floor;
    ChangeLift(prev_map, item, hexes, prev_door, false, false);
    ChangeLift(next_map, next_lift, hexes, next_door, true, false);

    if(next_floor == going_to){
        uint[] arr = {next_lift.Id, 0};
        CreateTimeEvent( __FullSecond + REAL_SECOND(2), "e_LiftMoving", arr, false );
    } else {        
        uint go_to_floor = (going_to<next_floor) ? (next_floor-1) : (next_floor+1);
        uint[] arr = {next_lift.Id, go_to_floor};
        uint delay = (prev_map.Id == next_map.Id) ? 3 : 5;
        CreateTimeEvent( __FullSecond + REAL_SECOND(delay), "e_LiftMoving", arr, false );
    }
    return true;
}

uint e_LiftMoving( uint[] @ val ) {
    if( !lifts_initialized ) {
        return 0;
    }
    if(val.length()!=2) {
        return 0;
    }
    Item@ item = GetItem(val[0]);
    if(item is null) {
        return 0;
    }
    MoveLiftTo(item, val[1], false);
    return 0;
}

#define MAX_ITEM_PROTOTYPES           ( 30000 )
bool CheckProtoId(int pid) {
    return pid > 0 && pid < MAX_ITEM_PROTOTYPES;
}

// next_floor is only valid with access == ACCESS_SELECT
bool CanAccessFloor(Critter& player, uint group, uint floor, uint8 access, uint next_floor=0) {
    string@ proto_name = GetTextMsgStr(FOTEXT_LIFT(group, 0));
    // if there is no field with keycard name - allow access
    if( proto_name is null )
        return true;
    int proto_id = GetProtoIdByName(proto_name);
    // if there is field with keycard name but it's invalid - forbid access
    if( !CheckProtoId(proto_id) ) {
        Log("Invalid keycard name: "+proto_name);
        return false;
    }

    if( player.CountItem( proto_id ) < 1 )
    {
        switch(access) {
            case ACCESS_INITAL:
            case ACCESS_SELECT:
                player.Say( SAY_NETMSG, "Приёмник ключ-карты моргнул. Возможно, без неё лифт не поедет." );
                break;
            case ACCESS_DOOR:
                player.Say( SAY_NETMSG, "Приёмник ключ-карты моргнул. Возможно, без неё вызвать лифт не удастся." );
                break;
        }
        return false;
    }
    else {
        switch(access) {
            case ACCESS_INITAL:
                femote_Gender(player, "вставил карточку в приёмник", "вставила карточку в приёмник");
                break;
            case ACCESS_DOOR:
                //don't say anything, doing that in another place
                break;
            case ACCESS_SELECT:
                // WIP: check if next floor can be accessed
                // player.Say( SAY_NETMSG, "Приёмник ключ-карты моргнул. Возможно, уровня доступа вашей карты недостаточно." );
                // return false;
                break;
        }
    }
    return true;
}

#endif //LIFT